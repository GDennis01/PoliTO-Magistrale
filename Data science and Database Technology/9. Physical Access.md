### Access methods
Data may be stored on disk  in different formats to provide efficient query execution.
The **Access Method Manager** transforms an access plan generated by the optimizer into a sequence of physical access requests to (database) disk pages.
It exploits **Access Methods**: software modules specialized for single physical data structures and that provide primitives for reading/writing data.
An **access method** selects the appropriate blocks of a file to  be loaded in memory by requesting them to the **Buffer Manager**

A disk page is divided in space for data, space reserved for access method control information and space reserved for file system information.

A table could extend to multiple pages, by having the tuples of dynamic size (ex. varchar) we can minimize the number of pages that need to be accessed. In case a record need to be modified and it takes a bigger space, if it not avaiable in that location the record is moved at another spot of the page or directly to another one if there is no space. So, there is an advanage in reading dynamic tuples but a disadvantage in writing.

If an operation *(like "order by")* cannot be fully executed in main memory, due to the huge set (N pages) of tuples in a table, the system:
- partition the records in some subset 
- stores them in secondary memory
- retreive them 1 by 1
- locally order them 
- perform some merging operation (ex. taking 2 at the time)
## Physical Access Structures
Describe how data is stored on disk to provide efficent query execution.
### Sequential structures
Tuples are stored in a given sequential order.
There are several sequential structures.
#### Heap file (unordered)
Tuples are sequenced in *insertion order* (appending at the end).
All space of a block is exploited before starting a new one. 
Additionally, *delete* and *update* may fragment the block, leading to wasted/unused space.
Sequential reading/writing is very efficient.
Usually, in relationa DBMS, it's coupled with unclustered indices to **support**search and sort operations since **heap file** alone doesn't order data in any way that allow a random access to memory.
Basically the heap alone does not support "where","group by", "order by" in an easy way.
#### Ordered sequential structure
Tuples are written according to  the value of a given **sort key** (that may contains more than 1 attribute)
It supports **sort** (and thus group-by), **search** and **join** operations on the sort key.
However, problems arise if we want to preserve the sort order when inserting new records. This problem is solved by leaving a percentage of free space in each block

Another solution is the using of an **overflow file:** an additional block created for the sole purpose of storing new tuples that don't fit in the correct block

This structure is often supported by a clustered **B<sup>+</sup>-tree** and is used by DBMS to store intermediate result.
#### Index
Indices are used to access memory directly in the location of interest.
Index key contains some attributes of the table (a few).
Index table contains, for each record, the values of the attributes in the index key and a pointer to the physical location in a certain block.

To identify the record of inteterest in a table:
- Read the index sequentially
- Find the correct one 
- Retreive full record from the correct location

Instead of being a sequential table, the index can be represented with different data structures to remove the "read the index sequentially" point:
#### (B-)Tree Structures
The "B" stands for balance: all path all have the length
Provide a "direct" access to data based on the value of a **key** field(s).
It doesn't costrain the physical position of tuples and it's the most used in DBMS.
It's structured as follows:
- **one** root node
- **many** intermediate nodes
- **many** children for each node
- **leaf** nodes provice access to actual data
**Leaf** nodes can either have direct access to the data(**clustered**) or having pointers to their actual location inside the main memory(**unclustered**).
In a **B<sup>+</sup>-tree**, leaf nodes are double-linked together with their successors (can traverse in both direction).
If the index covers all the information of a given query, it's called *covering index*.

**Unclustered** *(secondary)* **index:** index table decoupled from the table -> how data are organized in the index does not reflect in any way how data are organized in the table.

**Clustered** *(primary)* **index**: leaf nodes corrispond to the table. It is faster to access (cause you skip a layer) but the data in memory must be already ordered. Only 1 **clustered** index  can exist at a time and it is based on the attribute ordering the data in memory. Clustered index may cause additional overhead during deletion/insertion.

![[uncl_b+tree_ex.png]]
*Example of an unclustered B<sup>+</sup>-tree index on the grade attribute.*
<sub><sup>T1,T2.. are pyhisical pointers to the portion of the block</sup></sub>
Note: Grade\==30 contain 2 pointers, meaning that multiple pointer for a single index value are allowed.

![[clustered-BPlusTree.png]]
*Example of a clustered B<sup>+</sup>-tree index on the grade attribute.*
#### Hash indexes 
It guarantees direct and efficient access to data based on the value of a key field.
Supposing the hash structure has **B** blocks, the **hash function**, applied to the key field value of a record, returns a value between 0 and **B-1.** 
It's more efficient than a B-tree index in case of an equality predicate. It's not true for a range predicate as it will have to apply the hash function and access the block for every possible value in the range. 
It can be either clustered or unclustered(see above)
![[hash_index_clust.png]]
*Example of unclustered hash index*
![[unclusteredHashIndex.png]]
*Example of unclustered hash index*
### Bitmap indexes
It guarantees direct and efficient access to data based on the value of a key field and it's based on a *bit matrix*. It can support *group by* operations.
#### Bit matrix
There are as many rows as the number of records.
There are as many columns as the number of values the indexed attribute can assume.
Position($i,j$) is:
- 1 if tuple $i$ takes value $j$
- 0 otherwise.
![[bitmap_ex.png]]
*Example of bitmap index on attribute Job. The columns represent the values the attribute Job can assume. E.g. Tuple with RID=1 has Man. set to 1 as in that tuple, job assumes the value of Manager.*

This kind of index is very efficient for boolean expressions of predicates.
It can't be used for continous attributes(floating numbers for example).


#### B-tree vs Bitmap
B-trees size are calculated as *NRxLen(pointer)*, while Bitmap size is NRxNKxCS.
NR=Number of records | NK=Number of columns | CS=cell size in bitmap

While keeping NR constant, it can be seen from the graph below that Bitmap disk space can vary depending of number of attributes in the table.
![[B-treeVsBitmap.png|650]]